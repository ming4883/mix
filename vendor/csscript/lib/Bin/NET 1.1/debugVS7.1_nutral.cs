using System;
using System.Windows.Forms;
using System.IO;
using Microsoft.Win32;
using System.Xml;
using System.Collections;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Threading;
using System.Reflection;
using csscript;

namespace VS71
{ 
	class Script
	{
		static string usage = "Usage: cscscript debugVS7.1 [/prj] file ...\nLoads C# script file into temporary VS 7.1 C# project and opens it.\n</i> / </u> - command switch to install/uninstall shell extension\n</prj> - creates project without opening it\n";
													
		static public void Main(string[] args)
		{
			if (args.Length == 0 || (args.Length == 1 && (args[0] == "?" || args[0] == "/?" || args[0] == "-?" || args[0].ToLower() == "help")))
			{
				Console.WriteLine(usage);
			}
			else 
			{
				if (args[0].Trim().ToLower() == "/prj")
				{
					scriptFile = ResolveScriptFile(args[1]);
					
					try
					{
						VS71IDE ide = new VS71IDE();
						ide.IsolateProject(scriptFile, Path.Combine(Path.GetDirectoryName(scriptFile), Path.GetFileNameWithoutExtension(scriptFile)));
					}
					catch (Exception e)
					{
						MessageBox.Show("Specified file could not be linked to the temp project:\n" + e.Message);
					}
				}
				else
				{
					scriptFile =  ResolveScriptFile(args[0]);

					try
					{
						VS71IDE ide = new VS71IDE();
						ide.ComposeProject(scriptFile);

						ScriptMonitor monitor = new ScriptMonitor(scriptFile);

						Environment.CurrentDirectory = Path.GetDirectoryName(scriptFile);

						//open project

						Process myProcess = new Process();
						myProcess.StartInfo.FileName = VS71IDE.IDEFile;
						myProcess.StartInfo.Arguments = VS71IDE.GenerateCmdArgs(scriptFile);
						myProcess.Start();
						myProcess.WaitForExit();

						//do clean up
						foreach (string file in VS71IDE.filesToClean.Keys) //clean imported files
						{
							if (File.Exists(file))
							{
								File.SetAttributes(file, FileAttributes.Normal);
								File.Delete(file);
							}
						}
						if (File.Exists(Path.ChangeExtension(scriptFile, ".resx"))) //clean auto-generated files
							File.Delete(Path.ChangeExtension(scriptFile, ".resx"));
						Directory.Delete(VS71IDE.projectDir, true);  //clean whole project directory
					}
					catch (Exception e)
					{
						MessageBox.Show("Specified file could not be linked to the temp project:\n" + e.Message);
					}
				}
			}
		}
		static string ResolveScriptFile(string file)
		{
			if (Path.GetExtension(file) == "")
				return Path.GetFullPath(file + ".cs");
			else
				return Path.GetFullPath(file);
		}

		static string scriptFile;
		
		static string[] SearchDirs
		{
			get
			{
				string defaultConfig = Path.GetFullPath(Environment.ExpandEnvironmentVariables(@"%CSSCRIPT_DIR%\css_config.xml"));

				ArrayList retval = new ArrayList();

				if (scriptFile != null)
					retval.Add(Path.GetDirectoryName(Path.GetFullPath(scriptFile)));

				retval.Add(Environment.ExpandEnvironmentVariables(@"%CSSCRIPT_DIR%\lib"));

				if (File.Exists(defaultConfig))
				{
					foreach (string dir in Settings.Load(defaultConfig).SearchDirs.Split(';'))
						retval.Add(dir);
				}

                if (CSScriptLibrary.CSScript.GlobalSettings != null && CSScriptLibrary.CSScript.GlobalSettings.HideAutoGeneratedFiles == Settings.HideOptions.HideAll)
					retval.Add(CSSEnvironment.GetCacheDirectory(Path.GetFullPath(scriptFile)));

				return (string[])retval.ToArray(typeof(string));
			}
		}
		
		/// <summary>
		/// Class that monitors script file for changes and recreates project if required
		/// </summary>
		class ScriptMonitor
		{
			private string scriptFile;
			private Thread monitorThread;
			private int lastFileUpdateTime;

			public ScriptMonitor(string scriptFile)
			{
				this.scriptFile = scriptFile;

				FileSystemWatcher watcher = new FileSystemWatcher();
				watcher.Path = Path.GetDirectoryName(scriptFile);
				watcher.NotifyFilter = NotifyFilters.LastWrite;
				watcher.Filter = Path.GetFileName(scriptFile);
				watcher.Changed += new FileSystemEventHandler(OnChanged);
				watcher.EnableRaisingEvents = true;
			}
			public void OnChanged(object source, FileSystemEventArgs e)
			{
				lastFileUpdateTime = Environment.TickCount;
				if (monitorThread == null || !monitorThread.IsAlive)
				{
					monitorThread = new Thread(new ThreadStart(ThreadProc));
					monitorThread.Start();
				}
			}
			private void ThreadProc()
			{
				while ((Environment.TickCount - lastFileUpdateTime) < 500)
					Thread.Sleep(500);

				Thread.Sleep(500);

				if (IsProjectChanged())
				{
					VS71IDE ide = new VS71IDE();
					ide.ComposeProject(scriptFile);
				}
			}
			private string FileToKey(string file)
			{
				string key = Path.GetFileName(file);
				if (key.StartsWith("i_"))
					return key.Split("_".ToCharArray())[1].ToUpper();
				else
					return null;
			}
			private bool IsProjectChanged()
			{
                CSScriptLibrary.ScriptParser newParser = new CSScriptLibrary.ScriptParser(scriptFile, SearchDirs); //contains scriptFile + imported
                CSScriptLibrary.ScriptParser currentParser = VS71IDE.scriptParser;

				//check if number of source files in project has changed
				if (currentParser.FilesToCompile.Length != newParser.FilesToCompile.Length)
					return true;

				Hashtable htImported = new Hashtable();
				foreach (string file in newParser.FilesToCompile)
				{
					string key = FileToKey(file);
					if (key != null)
						htImported[key] = true;
				}

				foreach (string file in currentParser.FilesToCompile)
				{
					string key = FileToKey(file);
					if (key != null && !htImported.ContainsKey(key))
						return true;
				}

				
				//check if number of referrenced assemblies in project has changed
				ArrayList currentAssemblies = new ArrayList();
				foreach (string name in currentParser.ReferencedNamespaces)
                    foreach (string file in CSScriptLibrary.AssemblyResolver.FindAssembly(name, SearchDirs))
						currentAssemblies.Add(file);
				foreach (string file in currentParser.ReferencedAssemblies)
					currentAssemblies.Add(file);


				ArrayList newAssemblies = new ArrayList();
				foreach (string name in newParser.ReferencedNamespaces)
                    foreach (string file in CSScriptLibrary.AssemblyResolver.FindAssembly(name, SearchDirs))
						newAssemblies.Add(file);
				foreach (string file in newParser.ReferencedAssemblies)
					newAssemblies.Add(file);

				if (newAssemblies.Count != currentAssemblies.Count)
					return true;

				newAssemblies.Sort();
				currentAssemblies.Sort();
				foreach (string file in newAssemblies)
					if (0 > currentAssemblies.BinarySearch(file))
						return true;

				return false;
			}
		}

		public class VS71IDE
		{
			public static string solutionFile = "DebugScript.sln";
			static string templateProjectFile = "DebugScript.csproj";
			static string[] templateProjectFiles =	{	
														"App.ico", 
														"AssemblyInfo.cs", 
														templateProjectFile + ".user", 
														templateProjectFile,		
														solutionFile	
													};
			static string templateProjectDir = @"Lib\Debug\VS7.1";

            public static CSScriptLibrary.ScriptParser scriptParser;
			public static string projectDir;
			static public Hashtable filesToClean = new Hashtable();


			public VS71IDE()
			{
				if (projectDir == null)
					projectDir = Path.Combine(Path.Combine(Path.GetTempPath(), "CSSCRIPT"), Environment.TickCount.ToString());
				Directory.CreateDirectory(projectDir);
			}
			static public string GenerateCmdArgs(string scriptFile)
			{
				return "\"" + Path.Combine(projectDir, solutionFile) + "\" " + " /command Edit.OpenFile " + "\"" + scriptFile + "\"";
			}
			public string[] ComposeProject(string scriptFile)
			{
				string scHomeDir = GetEnvironmentVariable("CSSCRIPT_DIR");

				foreach (string file in templateProjectFiles)
				{
					File.Copy(Path.Combine(scHomeDir, Path.Combine(templateProjectDir, file)), Path.Combine(projectDir, file), true);
				}

                scriptParser = new CSScriptLibrary.ScriptParser(scriptFile, SearchDirs);

				SetWorkingDir(Path.GetDirectoryName(scriptFile), Path.Combine(projectDir, templateProjectFile) + ".user");
				InsertFile(scriptFile, Path.Combine(projectDir, templateProjectFile));

				string[] importerdScripts = scriptParser.SaveImportedScripts();
				foreach (string file in importerdScripts)
				{
					InsertFile(file, Path.Combine(projectDir, templateProjectFile));
					if (Path.GetFileName(file).StartsWith("i_")) //imported modified files have name "i_file_XXXXXX.cs>"
						filesToClean[file.ToUpper()] = true;
				}

                CSScriptLibrary.AssemblyResolver asmResolver = new CSScriptLibrary.AssemblyResolver();
				string[] referencedNamespaces = scriptParser.ReferencedNamespaces;

				foreach (string name in referencedNamespaces)
				{
                    bool ignore = false;
                    foreach (string ignoreName in scriptParser.IgnoreNamespaces)
                        if (ignore = (name == ignoreName))
                            break;

                    if (ignore)
                        continue;

                    string[] asmFiles = CSScriptLibrary.AssemblyResolver.FindAssembly(name, SearchDirs);
					foreach (string file in asmFiles)
					{
						InsertReference(Path.GetFileNameWithoutExtension(file), file, Path.Combine(projectDir, templateProjectFile));
					}
				}

				foreach (string asm in scriptParser.ReferencedAssemblies) //some assemblies were referenced from code
				{
					string asmName = Path.Combine(Path.GetDirectoryName(asm), Path.GetFileNameWithoutExtension(asm));
                    foreach (string file in CSScriptLibrary.AssemblyResolver.FindAssembly(asmName, SearchDirs))
					{
						InsertReference(Path.GetFileNameWithoutExtension(file), file, Path.Combine(projectDir, templateProjectFile));
					}
				}
				return importerdScripts;
			}

			public void IsolateProject(string scriptFile, string newProjectDir)
			{
				if (Directory.Exists(newProjectDir))
				{
					try
					{
						Directory.Delete(newProjectDir, true);
					}
					catch (Exception e)
					{
						throw new Exception("Cannot clean destination folder " + newProjectDir + "\n" + e.Message);
					}
				}
				Directory.CreateDirectory(newProjectDir);

				string newScriptFile = Path.Combine(newProjectDir, Path.GetFileName(scriptFile));
				File.Copy(scriptFile, newScriptFile);
				string scHomeDir = Environment.GetEnvironmentVariable("CSSCRIPT_DIR");

				foreach (string file in templateProjectFiles)
				{
					File.Copy(Path.Combine(scHomeDir, Path.Combine(templateProjectDir, file)), Path.Combine(newProjectDir, file), true);
				}

                scriptParser = new CSScriptLibrary.ScriptParser(scriptFile, SearchDirs);

				//main script file
				SetWorkingDir(newProjectDir, Path.Combine(newProjectDir, templateProjectFile) + ".user");
				InsertFile(newScriptFile, Path.Combine(newProjectDir, templateProjectFile), false);

				//imported scripts
				string[] importerdScripts = scriptParser.SaveImportedScripts();
				foreach (string file in importerdScripts)
				{
					string fileToInsert = file;
					if (Path.GetFileName(file).StartsWith("i_")) //rename imported files to their original names
					{
						int end = file.LastIndexOf("_");
						if (end != -1)
						{
							string newFile = Path.GetFileName(file.Substring(0, end).Replace("i_", "") + Path.GetExtension(file));
							newFile = Path.Combine(newProjectDir, newFile);
							if (File.Exists(newFile))
							{
								newFile = GetCopyName(newFile);
							}
							File.Move(file, newFile);
							fileToInsert = newFile;
						}
					}
					else if (file != scriptFile)
					{
						string newFile = newFile = Path.Combine(newProjectDir, Path.GetFileName(file));
						if (File.Exists(newFile))
						{
							newFile = GetCopyName(newFile);
						}
						File.Copy(file, newFile);
						fileToInsert = newFile;
					}
					InsertFile(fileToInsert, Path.Combine(newProjectDir, templateProjectFile), false);
				}

				//refernced dlls
                CSScriptLibrary.AssemblyResolver asmResolver = new CSScriptLibrary.AssemblyResolver();
				string[] referencedNamespaces = scriptParser.ReferencedNamespaces;

				foreach (string name in referencedNamespaces)
				{
                    string[] asmFiles = CSScriptLibrary.AssemblyResolver.FindAssembly(name, SearchDirs);
					foreach (string file in asmFiles)
					{
						string fileToInsert = file;
						if (file.IndexOf("assembly\\GAC") == -1 && file.IndexOf("assembly/GAC") == -1) //do not copy GAC files
						{
							fileToInsert = Path.Combine(newProjectDir, Path.GetFileName(fileToInsert));
							File.Copy(file, fileToInsert, true);
						}
						InsertReference(Path.GetFileNameWithoutExtension(fileToInsert), Path.GetFileName(fileToInsert), Path.Combine(newProjectDir, templateProjectFile));
					}
				}

				foreach (string asm in scriptParser.ReferencedAssemblies) //some assemblies were referenced from code
				{
					string asmName = Path.Combine(Path.GetDirectoryName(asm), Path.GetFileNameWithoutExtension(asm));
                    string[] asmFiles = CSScriptLibrary.AssemblyResolver.FindAssembly(asmName, SearchDirs);
					foreach (string file in asmFiles)
					{
						string fileToInsert = file;
						if (file.IndexOf("assembly\\GAC") == -1 && file.IndexOf("assembly/GAC") == -1) //do not copy GAC files
						{
							fileToInsert = Path.Combine(newProjectDir, Path.GetFileName(fileToInsert));
							File.Copy(file, fileToInsert, true);
						}
						InsertReference(Path.GetFileNameWithoutExtension(fileToInsert), Path.GetFileName(fileToInsert), Path.Combine(newProjectDir, templateProjectFile));
					}
				}

				//rename project files
				string newSolutionFile = Path.Combine(newProjectDir, Path.GetFileNameWithoutExtension(newScriptFile) + Path.GetExtension(solutionFile));
				string newProjectFile = Path.Combine(newProjectDir, Path.GetFileNameWithoutExtension(newScriptFile) + Path.GetExtension(templateProjectFile));

				File.Move(Path.Combine(newProjectDir, solutionFile), newSolutionFile);
				File.Move(Path.Combine(newProjectDir, templateProjectFile + ".user"), newProjectFile + ".user");

				using (StreamReader sr = new StreamReader(Path.Combine(newProjectDir, templateProjectFile)))
				using (StreamWriter sw = new StreamWriter(newProjectFile))
					sw.Write(sr.ReadToEnd().Replace(Path.GetFileNameWithoutExtension(solutionFile), Path.GetFileNameWithoutExtension(newProjectFile)));
				File.Delete(Path.Combine(newProjectDir, templateProjectFile));

				//repoint solution to the rigt project file
				string solutionText = "";
				using (StreamReader sr = new StreamReader(newSolutionFile))
				{
					solutionText = sr.ReadToEnd();
				}
				solutionText = solutionText.Replace("DebugScript", Path.GetFileNameWithoutExtension(newScriptFile));
				using (StreamWriter sw = new StreamWriter(newSolutionFile))
				{
					sw.Write(solutionText);
				}
				Console.WriteLine("Script " + Path.GetFileName(scriptFile) + " is isolated to folder: " + new DirectoryInfo(newProjectDir).FullName);
			}
			static public string GetCopyName(string file)
			{
				string retval = file;
				int i = 1;
				while (File.Exists(retval))
				{
					retval = Path.Combine(Path.GetDirectoryName(file), "Copy" + (i == 1 ? " of " : " (" + i.ToString() + ") ") + Path.GetFileName(file));
					i++;
				}
				return retval;
			}
			private void SetWorkingDir(string workingDir, string projUserFile)
			{
				XmlDocument doc = new XmlDocument();
				doc.Load(projUserFile);

				XmlNode settingsNode = doc.FirstChild.FirstChild.FirstChild.FirstChild;
				XmlNode debugConfigNode = settingsNode.ChildNodes[0];
				XmlNode releaseConfigNode = settingsNode.ChildNodes[1];

				debugConfigNode.Attributes.GetNamedItem("StartWorkingDirectory").Value = workingDir;
				releaseConfigNode.Attributes.GetNamedItem("StartWorkingDirectory").Value = workingDir;

				doc.Save(projUserFile);
			}

			private void LinkFile(string scriptFile, string templateProjectFile)
			{
				XmlDocument doc = new XmlDocument();
				doc.Load(templateProjectFile);

				XmlNode fileNode = doc.FirstChild.FirstChild.ChildNodes[1].FirstChild.LastChild;
				fileNode.Attributes.GetNamedItem("Link").Value = scriptFile;

				doc.Save(templateProjectFile);
			}

			private void InsertFile(string scriptFile, string templateProjectFile)
			{
				InsertFile(scriptFile, templateProjectFile, true);
			}

			private void InsertFile(string scriptFile, string templateProjectFile, bool link)
			{
				try
				{
					//<File RelPath="Sample.cs" Link="..\Sample.cs" SubType="Form" BuildAction="Compile" />
					XmlDocument doc = new XmlDocument();
					doc.Load(templateProjectFile);

					XmlNode fileNode = doc.FirstChild.FirstChild.ChildNodes[1].FirstChild.LastChild;

					//Create a new node.
					XmlElement elem = doc.CreateElement("File");
					XmlAttribute newAttr;

					newAttr = doc.CreateAttribute("RelPath");
					newAttr.Value = Path.GetFileName(scriptFile);
					elem.Attributes.Append(newAttr);

					if (link)
					{
						newAttr = doc.CreateAttribute("Link");
						newAttr.Value = scriptFile;
						elem.Attributes.Append(newAttr);
					}

					newAttr = doc.CreateAttribute("SubType");
					newAttr.Value = "Form";
					elem.Attributes.Append(newAttr);

					newAttr = doc.CreateAttribute("BuildAction");
					newAttr.Value = "Compile";
					elem.Attributes.Append(newAttr);

					doc.FirstChild.FirstChild.ChildNodes[1].FirstChild.InsertAfter(elem, fileNode);

					doc.Save(templateProjectFile);
				}
				catch (Exception e)
				{
					MessageBox.Show("Specified file could not be linked(inserted) to the temp project:\n" + e.Message);
				}
			}
			private void InsertReference(string refName, string refFile, string templateProjectFile)
			{
				try
				{
					//<Reference Name = "CSScriptLibrary" AssemblyName = "CSScriptLibrary" HintPath = "..\CSScriptLibrary.dll" />
					XmlDocument doc = new XmlDocument();
					doc.Load(templateProjectFile);

					XmlNode refNode = doc.FirstChild.FirstChild.FirstChild.ChildNodes[1].FirstChild;

					//Create a new node.
					XmlElement elem = doc.CreateElement("Reference");
					XmlAttribute newAttr;

					newAttr = doc.CreateAttribute("Name");
					newAttr.Value = refName;
					elem.Attributes.Append(newAttr);

					newAttr = doc.CreateAttribute("AssemblyName");
					newAttr.Value = refName;
					elem.Attributes.Append(newAttr);

					newAttr = doc.CreateAttribute("HintPath");
					newAttr.Value = refFile;
					elem.Attributes.Append(newAttr);

					doc.FirstChild.FirstChild.FirstChild.ChildNodes[1].InsertBefore(elem, refNode);

					doc.Save(templateProjectFile);
				}
				catch (Exception e)
				{
					MessageBox.Show("Specified reference could not be inserted into the temp project:\n" + e.Message);
				}
			}
			private string[] GetImportedFiles(string scriptFile)
			{
                CSScriptLibrary.ScriptParser parser = new CSScriptLibrary.ScriptParser(scriptFile, SearchDirs);
				return parser.SaveImportedScripts();
			}


			private static string ideFile;
			static public string IDEFile
			{
				get
				{
					if (ideFile != null)
						return ideFile;

					string retval = "<not defined>";
					
					RegistryKey csIDEFile = Registry.ClassesRoot.OpenSubKey("VisualStudio.csfile.7.1\\shell\\open\\command");

					if (csIDEFile != null)
					{
						retval = csIDEFile.GetValue("").ToString().TrimStart("\"".ToCharArray()).Split("\"".ToCharArray())[0];
					}
					ideFile = retval;
					return ideFile;
				}
			}

			static public string[] GetAvailableIDE()
			{
				if (VS71IDE.IDEFile != "<not defined>")
				{
					string scHomeDir = GetEnvironmentVariable("CSSCRIPT_DIR");
					
					return new string[] { 
						"Open with VS7.1",
						"\t- Open with MS Visual Studio 2003",
						"\"" + scHomeDir + "\\csws.exe\" /c \"" + scHomeDir + "\\lib\\DebugVS7.1.cs\" \"%1\""};
				}
				return null;
			}

			static public string GetEnvironmentVariable(string name)
			{
				//It is important in the all "installation" scripts to have reliable GetEnvironmentVariable().
				//Under some circumstances freshly set environment variable CSSCRIPT_DIR cannot be obtained with
				//Environment.GetEnvironmentVariable(). For example when running under Total Commander or similar 
				//shell utility. Even SendMessageTimeout does not help in all cases. That is why GetEnvironmentVariable
				//is reimplemented here.
				object value = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Control\Session Manager\Environment").GetValue(name);
				return value == null ? null : value.ToString();
			}
		}
	}
}